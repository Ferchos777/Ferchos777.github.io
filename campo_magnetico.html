<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Campo Magn√©tico</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .simulator-container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            margin-bottom: 25px;
        }

        .canvas-container {
            flex: 1;
            min-width: 600px;
            background: rgba(10, 15, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        #magneticFieldCanvas {
            background: #0a1020;
            border-radius: 8px;
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        .controls {
            flex: 0 0 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-panel {
            background: rgba(30, 35, 70, 0.8);
            border-radius: 10px;
            padding: 20px;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #ff7e5f;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-bar-magnet {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-wire {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-solenoid {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .btn-clear {
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            margin-top: 10px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }

        .instructions {
            background: rgba(30, 35, 70, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .instructions ul {
            padding-left: 20px;
            margin: 15px 0;
        }

        .instructions li {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            background: rgba(46, 204, 113, 0.2);
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Simulador de Campo Magn√©tico</h1>
            <p>Visualiza campos magn√©ticos generados por diferentes elementos</p>
        </header>
        
        <div class="simulator-container">
            <div class="canvas-container">
                <canvas id="magneticFieldCanvas" width="800" height="600"></canvas>
                <div class="status" id="status">Haz clic en un elemento y luego en el canvas para colocarlo</div>
            </div>
            
            <div class="controls">
                <div class="control-panel">
                    <h2>Elementos Magn√©ticos</h2>
                    <div class="button-group">
                        <button id="addBarMagnet" class="btn-bar-magnet">
                            üß≤ Im√°n de Barra
                        </button>
                        <button id="addWire" class="btn-wire">
                            ‚û∞ Cable con Corriente
                        </button>
                        <button id="addSolenoid" class="btn-solenoid">
                            üåÄ Solenoide
                        </button>
                        <button id="clearAll" class="btn-clear">
                            üóëÔ∏è Limpiar Todo
                        </button>
                    </div>
                    
                    <h2>Visualizaci√≥n</h2>
                    <div class="checkbox-group">
                        <label class="checkbox-item">
                            <input type="checkbox" id="showFieldLines" checked>
                            <span>L√≠neas de campo magn√©tico</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="showFieldVectors">
                            <span>Vectores de campo</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="showCompass">
                            <span>Br√∫julas</span>
                        </label>
                    </div>
                    
                    <h2>Configuraci√≥n</h2>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Intensidad:</span>
                            <span id="intensityValue">5</span>
                        </div>
                        <input type="range" id="fieldIntensity" min="1" max="10" value="5">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Densidad:</span>
                            <span id="densityValue">5</span>
                        </div>
                        <input type="range" id="lineDensity" min="1" max="10" value="5">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h2>Instrucciones de Uso</h2>
            <ul>
                <li><strong>Agregar elementos:</strong> Haz clic en un bot√≥n de elemento y luego en el canvas para colocarlo</li>
                <li><strong>Mover elementos:</strong> Haz clic y arrastra para mover los elementos</li>
                <li><strong>Rotar elementos:</strong> Haz clic en el c√≠rculo verde y arrastra para rotar</li>
                <li><strong>L√≠neas de campo:</strong> Muestran la direcci√≥n del campo magn√©tico</li>
                <li><strong>Br√∫julas:</strong> Indican la direcci√≥n del campo en diferentes puntos</li>
            </ul>
        </div>
    </div>

    <script>
        // Variables globales
        const canvas = document.getElementById('magneticFieldCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        
        // Configuraci√≥n
        const Œº0 = 4 * Math.PI * 1e-7; // Permeabilidad magn√©tica del vac√≠o
        let magneticElements = [];
        let selectedElement = null;
        let isDragging = false;
        let isRotating = false;
        let dragOffset = { x: 0, y: 0 };
        let elementToAdd = null;
        
        // Elementos de control
        const addBarMagnetBtn = document.getElementById('addBarMagnet');
        const addWireBtn = document.getElementById('addWire');
        const addSolenoidBtn = document.getElementById('addSolenoid');
        const clearAllBtn = document.getElementById('clearAll');
        const showFieldLines = document.getElementById('showFieldLines');
        const showFieldVectors = document.getElementById('showFieldVectors');
        const showCompass = document.getElementById('showCompass');
        const fieldIntensity = document.getElementById('fieldIntensity');
        const lineDensity = document.getElementById('lineDensity');
        const intensityValue = document.getElementById('intensityValue');
        const densityValue = document.getElementById('densityValue');
        
        // Actualizar valores de los sliders
        fieldIntensity.addEventListener('input', () => {
            intensityValue.textContent = fieldIntensity.value;
            draw();
        });
        
        lineDensity.addEventListener('input', () => {
            densityValue.textContent = lineDensity.value;
            draw();
        });
        
        // Clase base para elementos magn√©ticos
        class MagneticElement {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.angle = 0;
                this.isSelected = false;
            }
            
            draw() {
                // M√©todo que ser√° implementado por las subclases
            }
            
            containsPoint(x, y) {
                // M√©todo que ser√° implementado por las subclases
                return false;
            }
            
            getRotationHandle() {
                // M√©todo que ser√° implementado por las subclases
                return { x: this.x, y: this.y };
            }
            
            isRotationHandle(x, y) {
                const handle = this.getRotationHandle();
                const dx = x - handle.x;
                const dy = y - handle.y;
                return Math.sqrt(dx * dx + dy * dy) <= 10;
            }
        }
        
        // Clase para im√°n de barra
        class BarMagnet extends MagneticElement {
            constructor(x, y) {
                super(x, y, 'barMagnet');
                this.length = 120;
                this.width = 40;
                this.strength = 5e-6;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Dibujar el cuerpo del im√°n
                ctx.fillStyle = '#34495e';
                ctx.fillRect(-this.length/2, -this.width/2, this.length, this.width);
                
                // Dibujar los polos
                ctx.fillStyle = '#e74c3c'; // Norte (rojo)
                ctx.fillRect(-this.length/2, -this.width/2, this.length/2, this.width);
                
                ctx.fillStyle = '#3498db'; // Sur (azul)
                ctx.fillRect(0, -this.width/2, this.length/2, this.width);
                
                // Dibujar borde
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.length/2, -this.width/2, this.length, this.width);
                
                // Dibujar etiquetas de polos
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('N', -this.length/4, 0);
                ctx.fillText('S', this.length/4, 0);
                
                ctx.restore();
                
                // Dibujar manija de rotaci√≥n si est√° seleccionado
                if (this.isSelected) {
                    const handle = this.getRotationHandle();
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.8)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            containsPoint(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.angle);
                const sin = Math.sin(-this.angle);
                const tx = dx * cos - dy * sin;
                const ty = dx * sin + dy * cos;
                
                return Math.abs(tx) <= this.length/2 && Math.abs(ty) <= this.width/2;
            }
            
            getRotationHandle() {
                const handleDistance = this.length / 2 + 30;
                return {
                    x: this.x + Math.cos(this.angle) * handleDistance,
                    y: this.y + Math.sin(this.angle) * handleDistance
                };
            }
            
            calculateField(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const r = Math.sqrt(dx * dx + dy * dy);
                
                if (r < 5) return { Bx: 0, By: 0 };
                
                const theta = Math.atan2(dy, dx);
                const phi = theta - this.angle;
                
                const Br = (this.strength * Math.cos(phi)) / (r * r);
                const Bphi = (this.strength * Math.sin(phi)) / (2 * r * r);
                
                const Bx = Br * Math.cos(theta) - Bphi * Math.sin(theta);
                const By = Br * Math.sin(theta) + Bphi * Math.cos(theta);
                
                return { Bx, By };
            }
        }
        
        // Clase para cable con corriente
        class CurrentWire extends MagneticElement {
            constructor(x, y) {
                super(x, y, 'wire');
                this.length = 160;
                this.current = 5;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Dibujar cable
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(-this.length/2, 0);
                ctx.lineTo(this.length/2, 0);
                ctx.stroke();
                
                // Dibujar direcci√≥n de corriente
                ctx.fillStyle = '#f1c40f';
                
                // Flechas de direcci√≥n
                ctx.beginPath();
                ctx.moveTo(this.length/4, -10);
                ctx.lineTo(this.length/4 - 15, 0);
                ctx.lineTo(this.length/4, 10);
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(-this.length/4, -10);
                ctx.lineTo(-this.length/4 + 15, 0);
                ctx.lineTo(-this.length/4, 10);
                ctx.fill();
                
                ctx.restore();
                
                if (this.isSelected) {
                    const handle = this.getRotationHandle();
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.8)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            containsPoint(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.angle);
                const sin = Math.sin(-this.angle);
                const tx = dx * cos - dy * sin;
                const ty = dx * sin + dy * cos;
                
                return Math.abs(tx) <= this.length/2 && Math.abs(ty) <= 10;
            }
            
            getRotationHandle() {
                const handleDistance = this.length / 2 + 30;
                return {
                    x: this.x + Math.cos(this.angle) * handleDistance,
                    y: this.y + Math.sin(this.angle) * handleDistance
                };
            }
            
            calculateField(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.angle);
                const sin = Math.sin(-this.angle);
                const tx = dx * cos - dy * sin;
                const ty = dx * sin + dy * cos;
                
                const r = Math.abs(ty);
                if (r < 5) return { Bx: 0, By: 0 };
                
                const Bmag = (Œº0 * this.current) / (2 * Math.PI * r);
                let Bx = 0;
                let By = 0;
                
                if (ty > 0) {
                    Bx = Bmag * Math.cos(this.angle + Math.PI/2);
                    By = Bmag * Math.sin(this.angle + Math.PI/2);
                } else {
                    Bx = Bmag * Math.cos(this.angle - Math.PI/2);
                    By = Bmag * Math.sin(this.angle - Math.PI/2);
                }
                
                return { Bx, By };
            }
        }
        
        // Clase para solenoide
        class Solenoid extends MagneticElement {
            constructor(x, y) {
                super(x, y, 'solenoid');
                this.length = 180;
                this.radius = 30;
                this.turns = 8;
                this.current = 3;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Dibujar cuerpo del solenoide
                ctx.fillStyle = 'rgba(155, 89, 182, 0.7)';
                ctx.fillRect(-this.length/2, -this.radius, this.length, this.radius * 2);
                
                // Dibujar espiras
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 2;
                
                const turnSpacing = this.length / this.turns;
                for (let i = 0; i < this.turns; i++) {
                    const xPos = -this.length/2 + i * turnSpacing;
                    ctx.beginPath();
                    ctx.arc(xPos, 0, this.radius - 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Dibujar polos
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(this.length/2, 0, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(-this.length/2, 0, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Etiquetas de polos
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('N', this.length/2, 0);
                ctx.fillText('S', -this.length/2, 0);
                
                ctx.restore();
                
                if (this.isSelected) {
                    const handle = this.getRotationHandle();
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.8)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            containsPoint(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.angle);
                const sin = Math.sin(-this.angle);
                const tx = dx * cos - dy * sin;
                const ty = dx * sin + dy * cos;
                
                return Math.abs(tx) <= this.length/2 && Math.abs(ty) <= this.radius;
            }
            
            getRotationHandle() {
                const handleDistance = this.length / 2 + 40;
                return {
                    x: this.x + Math.cos(this.angle) * handleDistance,
                    y: this.y + Math.sin(this.angle) * handleDistance
                };
            }
            
            calculateField(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const cos = Math.cos(-this.angle);
                const sin = Math.sin(-this.angle);
                const tx = dx * cos - dy * sin;  // Coordenada x en sistema del solenoide
                const ty = dx * sin + dy * cos;  // Coordenada y en sistema del solenoide
                
                const n = this.turns / this.length;
                const I = this.current;
                
                let Bx = 0;
                let By = 0;
                
                // Determinar si estamos dentro del solenoide
                const inside = Math.abs(tx) <= this.length/2 && Math.abs(ty) <= this.radius;
                
                if (inside) {
                    // DENTRO del solenoide: campo uniforme y paralelo al eje
                    const Bmag = Œº0 * n * I * 500000; // Intensidad fuerte interna
                    Bx = Bmag * Math.cos(this.angle);
                    By = Bmag * Math.sin(this.angle);
                } else {
                    // FUERA del solenoide: tratar como un dipolo magn√©tico
                    
                    // Calcular distancia desde el centro
                    const r = Math.sqrt(tx * tx + ty * ty);
                    if (r < 5) return { Bx: 0, By: 0 };
                    
                    // Momento dipolar magn√©tico del solenoide
                    const area = Math.PI * this.radius * this.radius;
                    const magneticMoment = n * this.length * I * area;
                    
                    // √Ångulo relativo al eje del solenoide
                    const relAngle = Math.atan2(ty, tx);
                    const cosTheta = Math.cos(relAngle - this.angle);
                    const sinTheta = Math.sin(relAngle - this.angle);
                    
                    // Campo dipolar (f√≥rmula simplificada)
                    const Bmag = (Œº0 * magneticMoment) / (4 * Math.PI * r * r * r) * 1000000;
                    
                    // Componentes del campo dipolar
                    const Br = 2 * Bmag * cosTheta;
                    const Btheta = Bmag * sinTheta;
                    
                    // Convertir a coordenadas cartesianas locales
                    const Bx_local = Br * Math.cos(relAngle) + Btheta * Math.cos(relAngle + Math.PI/2);
                    const By_local = Br * Math.sin(relAngle) + Btheta * Math.sin(relAngle + Math.PI/2);
                    
                    // Rotar al sistema global
                    Bx = Bx_local * cos - By_local * sin;
                    By = Bx_local * sin + By_local * cos;
                }
                
                return { Bx, By };
            }
        }
        
        // Funci√≥n para calcular el campo magn√©tico total
        function calculateMagneticField(x, y) {
            let Bx = 0;
            let By = 0;
            
            for (const element of magneticElements) {
                const field = element.calculateField(x, y);
                Bx += field.Bx;
                By += field.By;
            }
            
            return { Bx, By };
        }
        
        // Funci√≥n para dibujar las l√≠neas de campo
        function drawFieldLines() {
            const density = parseInt(lineDensity.value);
            const step = 40 - density * 3;
            
            ctx.strokeStyle = 'rgba(255, 126, 95, 0.6)';
            ctx.lineWidth = 1.5;
            
            for (let x = 30; x < canvas.width; x += step) {
                for (let y = 30; y < canvas.height; y += step) {
                    drawFieldLine(x, y);
                }
            }
        }
        
        function drawFieldLine(startX, startY) {
            let x = startX;
            let y = startY;
            const maxSteps = 100;
            const stepSize = 3;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            
            for (let i = 0; i < maxSteps; i++) {
                const field = calculateMagneticField(x, y);
                const magnitude = Math.sqrt(field.Bx * field.Bx + field.By * field.By);
                
                if (magnitude < 1e-10) break;
                
                const normalizedBx = field.Bx / magnitude;
                const normalizedBy = field.By / magnitude;
                
                x += normalizedBx * stepSize;
                y += normalizedBy * stepSize;
                
                if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;
                
                ctx.lineTo(x, y);
            }
            
            ctx.stroke();
        }
        
        // Funci√≥n para dibujar vectores de campo
        function drawFieldVectors() {
            const step = 50;
            const intensity = parseInt(fieldIntensity.value);
            
            for (let x = 25; x < canvas.width; x += step) {
                for (let y = 25; y < canvas.height; y += step) {
                    const field = calculateMagneticField(x, y);
                    const magnitude = Math.sqrt(field.Bx * field.Bx + field.By * field.By);
                    
                    if (magnitude > 1e-10) {
                        const scale = 15 * intensity / 5;
                        const endX = x + (field.Bx / magnitude) * scale;
                        const endY = y + (field.By / magnitude) * scale;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = '#2ecc71';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        const angle = Math.atan2(endY - y, endX - x);
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - 6 * Math.cos(angle - Math.PI/6), endY - 6 * Math.sin(angle - Math.PI/6));
                        ctx.lineTo(endX - 6 * Math.cos(angle + Math.PI/6), endY - 6 * Math.sin(angle + Math.PI/6));
                        ctx.closePath();
                        ctx.fillStyle = '#2ecc71';
                        ctx.fill();
                    }
                }
            }
        }
        
        // Funci√≥n para dibujar br√∫julas
        function drawCompasses() {
            const step = 70;
            
            for (let x = 35; x < canvas.width; x += step) {
                for (let y = 35; y < canvas.height; y += step) {
                    const field = calculateMagneticField(x, y);
                    const magnitude = Math.sqrt(field.Bx * field.Bx + field.By * field.By);
                    
                    if (magnitude > 1e-10) {
                        const angle = Math.atan2(field.By, field.Bx);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 12, 0, Math.PI * 2);
                        ctx.strokeStyle = '#34495e';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        
                        ctx.fillStyle = '#e74c3c';
                        ctx.beginPath();
                        ctx.moveTo(0, -10);
                        ctx.lineTo(-5, 0);
                        ctx.lineTo(0, 10);
                        ctx.lineTo(5, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
            }
        }
        
        // Funci√≥n principal de dibujo
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (showFieldLines.checked) {
                drawFieldLines();
            }
            
            if (showFieldVectors.checked) {
                drawFieldVectors();
            }
            
            if (showCompass.checked) {
                drawCompasses();
            }
            
            for (const element of magneticElements) {
                element.draw();
            }
        }
        
        // Event Listeners para los botones
        addBarMagnetBtn.addEventListener('click', () => {
            elementToAdd = 'barMagnet';
            status.textContent = 'Haz clic en el canvas para colocar un im√°n de barra';
        });
        
        addWireBtn.addEventListener('click', () => {
            elementToAdd = 'wire';
            status.textContent = 'Haz clic en el canvas para colocar un cable con corriente';
        });
        
        addSolenoidBtn.addEventListener('click', () => {
            elementToAdd = 'solenoid';
            status.textContent = 'Haz clic en el canvas para colocar un solenoide';
        });
        
        clearAllBtn.addEventListener('click', () => {
            magneticElements = [];
            elementToAdd = null;
            selectedElement = null;
            status.textContent = 'Todos los elementos han sido eliminados';
            draw();
        });
        
        // Event Listeners para el canvas
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Verificar si se hizo clic en un elemento existente
            for (const element of magneticElements) {
                element.isSelected = false;
            }
            
            selectedElement = null;
            
            for (let i = magneticElements.length - 1; i >= 0; i--) {
                const element = magneticElements[i];
                
                if (element.isRotationHandle(x, y)) {
                    selectedElement = element;
                    isRotating = true;
                    element.isSelected = true;
                    status.textContent = 'Arrastra para rotar el elemento';
                    draw();
                    return;
                }
                
                if (element.containsPoint(x, y)) {
                    selectedElement = element;
                    isDragging = true;
                    element.isSelected = true;
                    dragOffset.x = x - element.x;
                    dragOffset.y = y - element.y;
                    status.textContent = 'Arrastra para mover el elemento';
                    draw();
                    return;
                }
            }
            
            // Si no se hizo clic en un elemento existente, agregar nuevo elemento
            if (elementToAdd) {
                let newElement;
                
                switch (elementToAdd) {
                    case 'barMagnet':
                        newElement = new BarMagnet(x, y);
                        break;
                    case 'wire':
                        newElement = new CurrentWire(x, y);
                        break;
                    case 'solenoid':
                        newElement = new Solenoid(x, y);
                        break;
                }
                
                if (newElement) {
                    magneticElements.push(newElement);
                    status.textContent = 'Elemento agregado. Haz clic y arrastra para mover o rotar';
                    draw();
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (isDragging && selectedElement) {
                selectedElement.x = x - dragOffset.x;
                selectedElement.y = y - dragOffset.y;
                draw();
            }
            
            if (isRotating && selectedElement) {
                const dx = x - selectedElement.x;
                const dy = y - selectedElement.y;
                selectedElement.angle = Math.atan2(dy, dx);
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isRotating = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isRotating = false;
        });
        
        // Event Listeners para los checkboxes
        showFieldLines.addEventListener('change', draw);
        showFieldVectors.addEventListener('change', draw);
        showCompass.addEventListener('change', draw);
        
        // Dibujar inicialmente
        draw();
        
        // Agregar algunos elementos de ejemplo
        magneticElements.push(new BarMagnet(300, 300));
        magneticElements.push(new CurrentWire(500, 200));
        draw();
    </script>
</body>

</html>
